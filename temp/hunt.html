<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GNDU Tactical Tracker</title>
    
    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        :root {
            --primary: #00ff9d;
            --bg: #050505;
            --panel: rgba(10, 20, 15, 0.95);
            --danger: #ff3333;
        }

        body { 
            margin: 0; 
            background: var(--bg); 
            color: white; 
            font-family: 'Courier New', Courier, monospace; 
            overflow: hidden; 
            touch-action: none;
            display: flex;
            align-items: center; /* Center the grid vertically */
            justify-content: center; /* Center the grid horizontally */
            height: 100vh;
            width: 100vw;
        }

        /* --- THE SCRAMBLED GRID --- */
        #grid-container {
            /* Width/Height will be set by JS to match Map Aspect Ratio */
            display: grid;
            grid-template-columns: repeat(5, 1fr); 
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.1);
        }

        .map-tile {
            position: relative;
            background: #111;
            overflow: hidden;
            border: 1px solid #333; 
        }

        /* High Contrast Map Tiles for readability */
        .leaflet-layer {
            filter: contrast(1.1) saturate(1.1) brightness(0.9);
        }

        .leaflet-control-container .leaflet-top, 
        .leaflet-control-container .leaflet-bottom { display: none !important; }

        /* --- HUD (Fixed on Screen) --- */
        #hud {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            background: var(--panel);
            border: 1px solid var(--primary);
            border-radius: 4px;
            padding: 15px;
            z-index: 5000;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
            backdrop-filter: blur(5px);
            transition: border-color 0.3s;
        }

        .hud-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .label { font-size: 10px; color: #888; letter-spacing: 1px; text-transform: uppercase; }
        .value { font-size: 16px; font-weight: bold; color: white; }
        .highlight { color: var(--primary); font-size: 18px; text-shadow: 0 0 5px var(--primary); }
        
        /* Danger State for Out of Zone */
        .out-of-zone { border-color: var(--danger) !important; box-shadow: 0 0 20px rgba(255, 50, 50, 0.3) !important; }
        .out-of-zone .highlight { color: var(--danger) !important; text-shadow: 0 0 5px var(--danger) !important; }

        #progress-bar { width: 100%; height: 4px; background: #333; margin-top: 10px; border-radius: 2px; }
        #progress-fill { height: 100%; width: 0%; background: var(--primary); transition: width 0.5s ease; box-shadow: 0 0 10px var(--primary); }

        /* --- MODALS --- */
        #modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px; box-sizing: border-box;
        }
        .modal-content { border: 2px solid var(--primary); padding: 30px; background: black; max-width: 400px; }
        h1 { color: var(--primary); margin: 0 0 10px 0; font-size: 24px; text-transform: uppercase; }
        p { color: #ccc; line-height: 1.5; font-family: sans-serif; }
        button { background: var(--primary); color: black; border: none; padding: 12px 24px; font-weight: bold; font-size: 16px; cursor: pointer; margin-top: 20px; text-transform: uppercase; }

        /* --- DEBUG --- */
        #debug-toggle { position: absolute; top: 10px; right: 10px; font-size: 20px; color: #333; cursor: pointer; z-index: 6000; }
        #debug-panel { display: none; position: absolute; top: 40px; right: 10px; background: rgba(0,0,0,0.9); border: 1px solid #555; padding: 10px; width: 200px; z-index: 6000; font-size: 10px; }
        
        /* --- MARKERS --- */
        .user-marker { width: 14px; height: 14px; background: #00aaff; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 10px #00aaff; animation: pulse-blue 2s infinite; }
        .target-marker { font-size: 24px; animation: bounce 1s infinite; filter: drop-shadow(0 4px 4px rgba(0,0,0,0.8)); }
        @keyframes pulse-blue { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

    </style>
</head>
<body>

    <div id="grid-container"></div>
    
    <div id="hud">
        <div class="hud-row">
            <div>
                <div class="label">CURRENT OBJECTIVE</div>
                <div class="value highlight" id="target-name">INITIALIZING...</div>
            </div>
            <div style="text-align: right;">
                <div class="label">DISTANCE</div>
                <div class="value" id="dist-display">--- m</div>
            </div>
        </div>
        <div class="hud-row">
            <div>
                <div class="label">GPS STATUS</div>
                <div class="value" style="font-size: 12px;" id="gps-status">Waiting...</div>
            </div>
            <div style="text-align: right;">
                <div class="label">CHECKPOINT</div>
                <div class="value" style="font-size: 12px;" id="checkpoint-count">0 / 0</div>
            </div>
        </div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h1 id="modal-title">MISSION UPDATE</h1>
            <p id="modal-msg">Briefing...</p>
            <button onclick="closeModal()">ACKNOWLEDGE</button>
        </div>
    </div>

    <div id="debug-toggle" onclick="toggleDebug()">‚öôÔ∏è</div>
    <div id="debug-panel">
        <div style="color:white; margin-bottom:5px;">ADMIN TOOLS</div>
        <button style="padding:5px; font-size:10px; width:100%;" onclick="copyCoords()">COPY MY COORDS</button>
        <button style="padding:5px; font-size:10px; width:100%; margin-top:5px; background:#444; color:white;" onclick="skipLevel()">SKIP LEVEL</button>
        <button style="padding:5px; font-size:10px; width:100%; margin-top:5px; background:#444; color:white;" onclick="toggleScramble()">TOGGLE SCRAMBLE</button>
        <div id="debug-coords" style="margin-top:5px; color:#0f0; word-break: break-all;"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ==================================================================
        // 1. EXACT GNDU POLYGON (Visual & Logic Border)
        // ==================================================================
        const GNDU_POLYGON = [ 
            [31.631552692516745, 74.83082324628221], 
            [31.641265976684306, 74.82907932842214], 
            [31.64008934348646, 74.81981781333435], 
            [31.630710083556302, 74.82104480288615]
        ];

        // 2. RESTRICTED ZONES (Excluded Areas inside the map)
        // Add polygons here to block them out. Users entering these will fail.
        const RESTRICTED_ZONES = [
            // Example Format: 
            // [ [31.6385, 74.8250], [31.6385, 74.8260], [31.6375, 74.8260], [31.6375, 74.8250] ],
        ];

        // 3. CHECKPOINTS (Must be inside polygon)
        const MISSIONS = [
            { name: "Botanical Garden",     lat: 31.6295, lng: 74.8235 }, // Adjusted slightly to fit new bounds
            { name: "Auditorium",           lat: 31.6370, lng: 74.8300 },
            { name: "Gurdwara Sahib",       lat: 31.6355, lng: 74.8255 },
            { name: "Dean Office",          lat: 31.6365, lng: 74.8250 },
            { name: "Bhai Gurdas Library",  lat: 31.6360, lng: 74.8265 },
            { name: "Chemistry Dept",       lat: 31.6350, lng: 74.8270 },
            { name: "Life Sciences",        lat: 31.6375, lng: 74.8230 },
            { name: "Physics Dept",         lat: 31.6340, lng: 74.8230 },
            { name: "Lecture Theatre (LC)", lat: 31.6358, lng: 74.8245 },
            { name: "Maths & CSE Dept",     lat: 31.6345, lng: 74.8220 },
            { name: "GJCEI",                lat: 31.6385, lng: 74.8200 },
            { name: "Law Department",       lat: 31.6380, lng: 74.8195 }, 
            { name: "Economics Dept",       lat: 31.6390, lng: 74.8190 }, 
            { name: "Children's Park",      lat: 31.6400, lng: 74.8210 },
            { name: "UIT (Technology)",     lat: 31.6405, lng: 74.8195 }
        ];

        // 4. AUTO-CALCULATE BOUNDING BOX FROM POLYGON
        const lats = GNDU_POLYGON.map(p => p[0]);
        const lngs = GNDU_POLYGON.map(p => p[1]);
        const MAP_BOUNDS = {
            north: Math.max(...lats),
            south: Math.min(...lats),
            east:  Math.max(...lngs),
            west:  Math.min(...lngs)
        };

        const CHECKPOINT_RADIUS_METERS = 35; 
        const GRID_ROWS = 5;
        const GRID_COLS = 5; 

        let currentLevel = 0;
        let mapTiles = [];
        let userPos = { lat: 0, lng: 0 };
        let isGameComplete = false;
        let isScrambled = true; // TOGGLE STATE

        function init() {
            // STEP 0: RESIZE GRID CONTAINER TO MATCH MAP ASPECT RATIO
            // This prevents tiles from repeating content by ensuring the div shape matches the map shape.
            optimizeGridDimensions();

            renderGrid();
            loadMission(0);
            startTracking();
        }

        function optimizeGridDimensions() {
            const container = document.getElementById('grid-container');
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;

            // Calculate Map Real World Dimensions (approx meters)
            const latDiff = MAP_BOUNDS.north - MAP_BOUNDS.south;
            const lngDiff = MAP_BOUNDS.east - MAP_BOUNDS.west;
            const avgLat = (MAP_BOUNDS.north + MAP_BOUNDS.south) / 2;
            
            // 1 degree lat ~ 111132m, 1 degree lng ~ 111132 * cos(lat)
            const metersH = latDiff * 111132;
            const metersW = lngDiff * 111132 * Math.cos(avgLat * Math.PI / 180);
            
            const mapRatio = metersW / metersH;
            const screenRatio = screenW / screenH;

            // Adjust container size
            if (screenRatio > mapRatio) {
                // Screen is wider than map -> constrain width by height
                container.style.height = '100vh';
                container.style.width = (screenH * mapRatio) + 'px';
            } else {
                // Screen is taller than map -> constrain height by width
                container.style.width = '100vw';
                container.style.height = (screenW / mapRatio) + 'px';
            }
        }

        function toggleScramble() {
            isScrambled = !isScrambled;
            // Clear existing grid
            mapTiles.forEach(t => t.map.remove());
            mapTiles = [];
            document.getElementById('grid-container').innerHTML = '';
            
            renderGrid();
            alert("Map Mode: " + (isScrambled ? "SCRAMBLED" : "ORDERED (NORMAL)"));
        }

        function renderGrid() {
            const container = document.getElementById('grid-container');
            const latSpan = MAP_BOUNDS.north - MAP_BOUNDS.south;
            const lngSpan = MAP_BOUNDS.east - MAP_BOUNDS.west;
            const cellH = latSpan / GRID_ROWS;
            const cellW = lngSpan / GRID_COLS;

            let tiles = [];

            const worldBox = [[90, -180], [90, 180], [-90, 180], [-90, -180]];
            
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const div = document.createElement('div');
                    div.className = 'map-tile';
                    div.id = `tile-${r}-${c}`;
                    div.dataset.row = r;
                    div.dataset.col = c;
                    
                    const bN = MAP_BOUNDS.north - (r * cellH);
                    const bS = bN - cellH;
                    const bW = MAP_BOUNDS.west + (c * cellW);
                    const bE = bW + cellW;

                    div.dataset.bounds = JSON.stringify([[bS, bW], [bN, bE]]);
                    tiles.push(div);
                }
            }

            // Shuffle ONLY if scrambled mode is ON
            if (isScrambled) {
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
            }

            tiles.forEach(tile => {
                container.appendChild(tile);
                const bounds = JSON.parse(tile.dataset.bounds);
                const latLngBounds = L.latLngBounds(bounds);

                const map = L.map(tile.id, {
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    touchZoom: false,
                    zoomSnap: 0, // FIXED: Allows fractional zoom for perfect fit
                    // STRICT BOUNDS to prevent seeing neighbor tiles
                    maxBounds: latLngBounds,
                    maxBoundsViscosity: 1.0
                });

                // Force fit exactly
                map.fitBounds(latLngBounds, { padding: [0, 0] });
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    maxNativeZoom: 19,
                    detectRetina: true, // Crisp tiles on mobile
                    opacity: 1
                }).addTo(map);

                // --- ADD THE MASK ---
                L.polygon([worldBox, GNDU_POLYGON], {
                    color: 'transparent',
                    fillColor: '#000000',
                    fillOpacity: 0.85
                }).addTo(map);

                // --- DRAW RESTRICTED ZONES ---
                RESTRICTED_ZONES.forEach(zone => {
                    L.polygon(zone, {
                        color: '#ff3333',
                        fillColor: '#ff3333',
                        fillOpacity: 0.4,
                        weight: 1,
                        dashArray: '5, 5'
                    }).addTo(map);
                });

                // Draw Border
                L.polygon(GNDU_POLYGON, {
                    color: '#00ff9d',
                    weight: 2,
                    fill: false,
                    dashArray: '5, 10'
                }).addTo(map);

                mapTiles.push({
                    id: tile.id,
                    element: tile,
                    map: map,
                    bounds: latLngBounds,
                    userMarker: null,
                    targetMarker: null
                });
            });
        }

        // Ray-casting algorithm
        function isPointInPolygon(lat, lng, poly) {
            let x = lat, y = lng;
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                let xi = poly[i][0], yi = poly[i][1];
                let xj = poly[j][0], yj = poly[j][1];
                
                let intersect = ((yi > y) != (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function startTracking() {
            if (!navigator.geolocation) {
                showModal("ERROR", "GPS Not Supported");
                return;
            }

            navigator.geolocation.watchPosition(
                (pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    const acc = pos.coords.accuracy;
                    userPos = { lat, lng };

                    // 1. Check if Inside Main Zone
                    let inZone = isPointInPolygon(lat, lng, GNDU_POLYGON);
                    let inRestricted = false;

                    // 2. Check if Inside Any Restricted Zone
                    if (inZone) {
                        for (let zone of RESTRICTED_ZONES) {
                            if (isPointInPolygon(lat, lng, zone)) {
                                inRestricted = true;
                                break;
                            }
                        }
                    }
                    
                    if (!inZone) {
                        document.getElementById('hud').classList.add('out-of-zone');
                        document.getElementById('gps-status').innerText = "OUT OF BOUNDS";
                        document.getElementById('gps-status').style.color = "red";
                        document.getElementById('target-name').innerText = "RETURN TO ZONE";
                    } else if (inRestricted) {
                        document.getElementById('hud').classList.add('out-of-zone');
                        document.getElementById('gps-status').innerText = "RESTRICTED ZONE";
                        document.getElementById('gps-status').style.color = "red";
                        document.getElementById('target-name').innerText = "BACK AWAY";
                    } else {
                        document.getElementById('hud').classList.remove('out-of-zone');
                        document.getElementById('gps-status').innerText = `Active (¬±${Math.round(acc)}m)`;
                        document.getElementById('gps-status').style.color = "white";
                        if(document.getElementById('target-name').innerText === "RETURN TO ZONE" || document.getElementById('target-name').innerText === "BACK AWAY") {
                            document.getElementById('target-name').innerText = MISSIONS[currentLevel].name;
                        }
                    }

                    // Treat Restricted as Out of Zone for game loop
                    updateGameLoop(lat, lng, inZone && !inRestricted);
                },
                (err) => { document.getElementById('gps-status').innerText = "NO SIGNAL"; },
                { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
            );
        }

        function updateGameLoop(lat, lng, isSafe) {
            if (isGameComplete) return;

            const target = MISSIONS[currentLevel];
            const userLatLng = L.latLng(lat, lng);
            const targetLatLng = L.latLng(target.lat, target.lng);

            // 1. Distance
            const dist = userLatLng.distanceTo(targetLatLng);
            document.getElementById('dist-display').innerText = `${Math.round(dist)} m`;

            // 2. Win Check (Must be safe)
            if (isSafe && dist <= CHECKPOINT_RADIUS_METERS) {
                levelComplete();
            }

            // 3. Update Markers
            mapTiles.forEach((tile, index) => {
                if (tile.userMarker) { tile.map.removeLayer(tile.userMarker); tile.userMarker = null; }
                if (tile.targetMarker) { tile.map.removeLayer(tile.targetMarker); tile.targetMarker = null; }

                if (tile.bounds.contains(userLatLng)) {
                    const icon = L.divIcon({ className: 'user-marker', iconSize: [20, 20] });
                    tile.userMarker = L.marker([lat, lng], {icon: icon}).addTo(tile.map);
                }

                if (tile.bounds.contains(targetLatLng)) {
                    const emoji = currentLevel === MISSIONS.length - 1 ? 'üèÅ' : '‚≠ê';
                    const icon = L.divIcon({ 
                        className: 'target-marker', 
                        html: emoji, 
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    });
                    tile.targetMarker = L.marker([target.lat, target.lng], {icon: icon}).addTo(tile.map);
                }
            });
        }

        function loadMission(index) {
            if (index >= MISSIONS.length) {
                gameWon();
                return;
            }
            const mission = MISSIONS[index];
            document.getElementById('target-name').innerText = mission.name;
            document.getElementById('checkpoint-count').innerText = `${index + 1} / ${MISSIONS.length}`;
            const pct = ((index) / MISSIONS.length) * 100;
            document.getElementById('progress-fill').style.width = `${pct}%`;

            if(index === 0) showModal("MISSION START", `Target: ${mission.name}.<br>Stay inside the Green Border.`);
        }

        function levelComplete() {
            if(document.getElementById('modal-overlay').style.display === 'flex') return;
            currentLevel++;
            if (currentLevel >= MISSIONS.length) {
                gameWon();
            } else {
                const nextMission = MISSIONS[currentLevel];
                showModal("CHECKPOINT REACHED", `Next Target: <b style="color:var(--primary)">${nextMission.name}</b>`);
                loadMission(currentLevel);
            }
        }

        function gameWon() {
            isGameComplete = true;
            document.getElementById('progress-fill').style.width = `100%`;
            showModal("VICTORY", "Welcome to UIT.<br>Mission Accomplished.");
            document.getElementById('target-name').innerText = "COMPLETE";
            document.getElementById('hud').style.borderColor = "gold";
        }

        function showModal(title, msg) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-msg').innerHTML = msg;
            document.getElementById('modal-overlay').style.display = 'flex';
        }
        function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
        function toggleDebug() { const p = document.getElementById('debug-panel'); p.style.display = p.style.display === 'block' ? 'none' : 'block'; }
        function copyCoords() {
            const str = `{ name: "Point", lat: ${userPos.lat.toFixed(5)}, lng: ${userPos.lng.toFixed(5)} },`;
            document.getElementById('debug-coords').innerText = str;
            navigator.clipboard.writeText(str);
            alert("Copied!");
        }
        function skipLevel() { levelComplete(); }

        init();
    </script>
</body>
</html>
